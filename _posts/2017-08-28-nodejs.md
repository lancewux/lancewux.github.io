<h1 align="center"> node js</h1>

模块
-

在执行一个模块之前，会先用 function wrapper包裹起来。包裹的好处是防止模块变量污染全局环境。使module，exports，__filename，__dirname为特定的模块变量。

```javascript
(function(exports, require, module, __filename, __dirname) {
// Your module code actually lives in here
});
```

require的大致实现。exports只是module.exports的一个引用。

```javascript
function require(/* ... */) {
  const module = { exports: {} };
  ((module, exports) => {
    // Your module code here. In this example, define a function.
    function someFunc() {}
    exports = someFunc;
    // At this point, exports is no longer a shortcut to module.exports, and
    // this module will still export an empty default object.
    module.exports = someFunc;
    // At this point, the module will now export someFunc, instead of the
    // default object.
  })(module, module.exports);
  return module.exports;
}
```

模块在第一次加载时就被缓存了。多次require同一个文件只会执行一次该文件。

a.js和b.js循环依赖的解析过程。首先加载并运行a.js，碰到reqire('./b.js')时，停止运行a.js，加载并运行b.js，碰到reqire('./a.js')时，获取一个不完全版的a.js的exports对象，继续运行b.js，回去运行a.js。

如果 a.js require 了 b.js, 那么在 b 中定义全局变量 t = 111(未用var声明) 能在 a 中直接打印出来.

热更新
-

对客户端而言, 热更新意味着不用换包, 当然也包含着 md5 校验/差异更新等复杂问题; 对服务端而言, 热更新意味着服务不用重启。

在 Node.js 中做热更新代码, 牵扯到的知识点可能主要是 require 会有一个 cache, 有这个 cache 在, 即使你更新了 .js 文件, 在代码中再次 require 还是会拿到之前的编译好缓存在 v8 内存 (code space) 中的的旧代码. 


Events
-

Node.js 中 Eventemitter 的 emit 是同步的:

```javascript
const EventEmitter = require('events');

let emitter = new EventEmitter();

emitter.on('myEvent1', () => {
  console.log('1');
  emitter.emit('myEvent2');
  console.log('3');
});

emitter.on('myEvent2', () => {
  console.log('2');
});

emitter.emit('myEvent1');
// 1 2 3 
```

sleep 函数

```javascript
function sleep(ms) {
  var start = Date.now(), expire = start + ms;
  while (Date.now() < expire) ;
  return;
}

function sleepp(ms) {
  var start = (new Date()).getTime(), expire = start + ms;
  while ((new Date()).getTime() < expire) ;
  return;
}
```


