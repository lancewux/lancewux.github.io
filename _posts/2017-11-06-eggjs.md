<h1 align="center"> egg.js </h1>

cluster
-

一个nodejs的实例运行在一个单线程中。为了利用系统的多核资源，nodejs提供了cluster模块。使用cluster模块可以很容易地创建共享服务端口号的多个子进程。

cluster包括一个master父进程和多个worker子进程。worker子进程用child_process.fork() 创建，所以父子进程间可以通过ipc channel进程通信。cluster支持两种分发请求的方法，一种是 round-robin，另一种是分发给有兴趣的worker进程。worker进程间是相互独立的，只要有一个worker还活着，服务器就会继续接受并处理请求。cluster并不管理worker进程的数量。

cluster实现worker子进程共享socket端口号的原理是。nodejs初始化会根据环境变量来判断是否为cluster模块fork出的worker进程，从而分别执行workerInit()和masterInit()函数来初始化环境。workerInit()的listen方法会调用cluster._getServer方法，该方法会进程判断，若master进程是第一次接收此端口号的worker，则申请一个内部TCP服务器来承担监听该端口的职责，同时hack掉listen方法里实现监听端口功能的部分。master进程会监听TCP服务器的connection事件，挑选出一个worker进程并发送newconn内部消息，把请求交由该worker进程处理。

egg-cluster
-

egg-cluster包括一个master进程、一个agent worker进程和多个app worker进程。agent worker使用child_process.fork() 创建，而app worker用cluster.fork()创建。

首先探测可用的端口号，

然后使用child_process.fork()创建agentWorker，监听error事件并记录日志，监听exit事件并向master发送agent-exit消息。

调用cfork.fork()创建AppWorkers，cfork.fork()调用的是cluster.fork()创建进程。监听disconnect事件并记录日志，监听exit事件并向master发送app-exit消息。

所有的进程初始化成功后，Master 通知 Agent 和 Worker 应用启动成功。

处理进程的异常退出：在graceful模块监听'uncaughtException'事件，使进程优雅地退出，包括关闭异常 Worker 进程所有的 TCP Server（通过设置`Connection: close` header断开连接，server.close()关闭server），断开和 Master 的 IPC 通道（调用worker.disconnect()），超时关闭进程（调用process.exit(1)）。如果没有io在等待就直接关闭进程。exit事件主要是在cfork模块进行处理的。cfork会监听disconnect和exit事件，并判断触发事件的原因的类型，然后重新fork进程。因为disconnect和exit事件的先后顺序是不确定的，所以两个事件的监听回调函数都要fork进程的工作，理想情况下是先disconnect再exit。

在master中监听app-exit和agent-exit事件，做相应处理：记录相关日志，清除所有已注册的事件监听函数，释放pid，

master会监听SIGINT，SIGQUIT，SIGTERM和exit事件，然后杀死agentWorker和AppWorkers，通过调用removeAllListeners()和kill('SIGTERM')来完成。

### 通信

cluster 的 IPC 通道只存在于 Master 和 Worker/Agent 之间，Worker 与 Agent 进程互相间是没有的。egg-cluster进行了扩展，Worker之间和worker与agent之间的通讯通过 Master 来转发，这些功能封装在messenger模块中。

但是，通过 messenger 传递数据效率是比较低的，因为它会通过 Master 来做中转；万一 IPC 通道出现问题还可能将 Master 进程搞挂。

对于建立长连接的业务场景，会把它放到 Agent 进程里维护，然后通过 messenger 将数据传递给各个 Worker。往往需要写大量代码去封装接口和实现数据的传递，非常麻烦。

另外一种解决方法是Leader/Follower 模式。客户端会被区分为Leader和Follower两种角色。Leader负责和远程服务端维持连接，对于同一类的客户端只有一个 Leader。Follower会将具体的操作委托给 Leader，常见的是订阅模型。

框架里面采用的是强制指定模式，Leader 只能在 Agent 里面创建。

Leader 和 Follower 之间通过 socket 直连（通过通讯端口），不再需要 Master 中转。

### 加载过程

首先fork了egg-cluster的agent_worker.js, 实例化egg/lib/agent.js里的Agent类，构造函数里面调用this.loader.load()，Agent类继承自egg/lib/egg.js的EggApplication类，构造函数里面调用this.loader.loadConfig()，EggApplication类继承自egg-core/lib/egg.js里的EggCore类，构造函数里面初始化this.loader，实例化自egg-core/lib/loader/egg_loader.js，EggCore类则继承自KoaApplication类。

加载类的顺序是

Application config -> framework config.default -> app config.default -> plugin config.{env} -> framework config.{env} -> app config.{env}


