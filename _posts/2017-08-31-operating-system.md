<h1 align="center"> 操作系统 </h1>

TTY
-

"tty" 原意是指 "teletype" 即打字机, "pty" 则是 "pseudo-teletype" 即伪打字机. 在 Unix 中, /dev/tty* 是指任何表现的像打字机的设备, 例如终端 (terminal).

使用 ps -x 命令查看进程信息中也有 tty 的信息。其中为 ? 的是没有依赖 TTY 的进程, 即守护进程.

EOL
-

换行符 (EOL) 通常由 line feed (LF, \\n, 回到最左边) 和 carriage return (CR, \\r, 换行) 组成. 常见的情况:

|符号|系统|
|:--|:----|
|LF|在 Unix 或 Unix 相容系统 (GNU/Linux, AIX, Xenix, Mac OS X, ...)、BeOS、Amiga、RISC OS|
|CR+LF|MS-DOS、微软视窗操作系统 (Microsoft Windows)、大部分非 Unix 的系统|
|CR|Apple II 家族, Mac OS 至版本9|


孤儿进程
-

孤儿进程是指这样一类进程：在进程还未退出之前，它的父进程就已经退出了，一个没有了父进程的子进程就是一个孤儿进程（orphan）。

既然所有进程都必须在退出之后被wait()或waitpid()以释放其遗留在系统中的一些资源，那么应该由谁来处理孤儿进程的善后事宜呢？这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程“凄凉地”结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。

僵尸进程
-

Unix进程模型中，进程是按照父进程产生子进程，子进程产生子子进程这样的方式创建出完成各项相互协作功能的进程的。

当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。如果父进程没有这么做的话，会产生什么后果呢？此时，子进程虽然已经退出了，但是在系统进程表中还为它保留了一些退出状态的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)，如果父进程一直不取得这些退出信息的话，这些进程表项就将一直被占用，此时，这些占着茅坑不拉屎的子进程就成为“僵尸进程”（zombie）。系统进程表是一项有限资源，如果系统进程表被僵尸进程耗尽的话，系统就可能无法创建新的进程。

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

严格地来说，僵尸进程并不是问题的根源，罪魁祸首是产生出大量僵尸进程的那个父进程。

处理僵尸进程的方法有两种：

一是通过信号机制。子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程。

二是fork两次。fork一次，然后wait，再让fork出来的子进程fork一个孙子进程出来，然后子进程自杀，然后父进程通过wait回收子进程，此时孙子进程直接被init进程收养，死了自动回收。

进程崩溃的原因
-

#### 堆栈溢出异常

分配给线程堆栈的内存耗尽时就会发生内存溢出异常。

#### 内存溢出异常

大多数情况下内存溢出是由设计问题导致的，要么是cache或者session使用了过多的内存.

#### 本地堆冲突

写入了错误内存地址就会发生本地堆冲突.随之而来的问题在于:写入错误的内存地址不会发生任何错误，而当其他程序用正确方式访问这个地址的时候才会出错.

消息队列（Message queue）
-

<a href="https://en.wikipedia.org/wiki/Message_queue" target="_blank">消息队列</a>提供了一种异步通信协议，消息的发送者和接收者不需要在同一时间和消息队列打交道。消息会一直存在消息队列中，直到接收者取走它们。在计算机科学中，消息队列是用于IPC（inter-process communication）或ITC（inter-thread communication ）的软件工程组件。




