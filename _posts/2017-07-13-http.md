<h1 align="center"> HTTP</h1>

HTTP协议状态码
-

HTTP协议状态码表示的意思主要分为五类 ,大体是 : 

- 1×× 　　指定客户端相应的某些动作。
- 2×× 　　表示请求成功地接收   
- 3×× 　　为完成请求客户需进一步细化请求   
- 4×× 　　客户错误   
- 5×× 　　服务器错误  

#### 100 Continue

这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。

#### 101 Switching Protocols

指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。 

只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送可以利用此类特性的资源。

#### 200 OK

请求已成功，请求所希望的响应头或数据体将随此响应返回。一般用于GET与POST请求。

#### 201 Created

请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 '202 Accepted'。

#### 202 Accepted

服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。

返回202状态码的响应的目的是允许服务器接受其他过程的请求。例如处理某个每天只执行一次的基于批处理的操作，不必让客户端一直保持与服务器的连接直到批处理操作全部完成。

#### 203 Non-Authoritative Information

状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。

#### 204 No Content

无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档。

这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。

#### 205 Reset Content

重置内容，虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。 

#### 206 Partial Content

这是 HTTP 1.1中新加入的。 

服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。

该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。

响应必须包含如下的头部域：

Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。

#### 300 Multiple Choices

被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。

除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。

如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。

#### 301 Moved Permanently

被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。

新的永久性的URI 应当在响应的 Location 域中返回。

如果这不是一个 GET 或者 HEAD 请求，浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。

注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。

#### 302 Found

在 HTTP 1.0中，是Moved Temporarily。

临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI。

如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。

如果客户端发出POST请求后，收到服务端的302状态码，那么不能自动的向新的URI发送重复请求，必须跟用户确认是否该重发，因为第二次POST时，环境可能已经发生变化（嗯，POST方法不是幂等的），POST操作会不符合用户预期。

但是，很多浏览器在这种情况下都会把POST请求变为GET请求。为了兼容这种浏览器的行为，HTTP 1.1引入了303和307。它们是对HTTP1.0中的302状态码的细化，主要用在对非GET、HEAD方法的响应上。

对于303状态码的响应，浏览器可以自动把POST重定向为GET请求。
对于307状态码的响应，当客户端的POST请求收到服务端307状态码响应时，需要跟用户询问是否应该在新URI上发起POST方法，也就是说，307是不会把POST转为GET的。

#### 303 See Other

这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在location头信息中给出）要用 GET 找回。这个状态码是新加入 HTTP 1.1中的。 

#### 304 Not Modified

如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。

#### 305 Use Proxy

表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。 

#### 306 Switch Proxy

在最新版的规范中，306状态码已经不再被使用。

#### 307 Temporary Redirect

浏览器处理307状态的规则与302相同。如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。

#### 400 Bad Request

语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。

请求参数有误。

#### 401 Unauthorized

当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。

#### 402 Payment Required

该状态码是为了将来可能的需求而预留的。

#### 403 Forbidden

服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。

#### 404 Not Found

请求失败，请求所希望得到的资源未在服务器上发现。

404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。

#### 405 Method Not Allowed

请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。

鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。

#### 406 Not Acceptable

请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。

#### 407 Proxy Authentication Required

与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。

#### 408 Request Timeout

服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。 

#### 409 Conflict

由于和被请求的资源的当前状态之间存在冲突，请求无法完成。

该状态通常与PUT请求一同使用，409 状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。 

#### 500 Internal Server Error

服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。代码错误或数据库操作错误。

#### 501 Not Implemented

服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。 

#### 502 Bad Gateway

作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。

#### 503 Service Unavailable

由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。例如，如果某些线程或数据库连接池已经没有空闲则会返回这个头信息。

#### 504 Gateway Timeout

作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。

#### 505 HTTP Version Not Supported

服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。

#### 506 Variant Also Negotiates

代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。

#### 507 Insufficient Storage

服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。

#### 509 Bandwidth Limit Exceeded

服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。

#### 600 Unparseable Response Headers

源站没有返回响应头部，只返回实体内容

请求方法method
-

#### GET

Get方法是最简单最常用的请求方法。它被用来访问静态资源，比如HTML文档和图片等。Get请求可以通过在请求URL中包含查询参数的方法来检索动态信息。例如，我们可以通过URL发送“name”这个参数(http://www.domain.com?name=Harsh)，在这个例子中，Harsh是通过在请求URL中包含参数“name”的动态的信息。Web服务可以通过这个“name”参数来访问动态信息。

#### HEAD

根据维基百科“要求响应上等同于Get请求，但是没有响应Body（Response Body）。这在检索写在响应头(Response Header)中的信息而不需要传输全部的内容的情况下非常有用。”当客户端请求关于一个资源的一些信息而不是请求全部资源的时候使用Head方法。这意味着我们有一种快速的方式来检查针对服务端上一个给定的资源的头信息和一些服务端信息，检测一个给定的url是否可用、给定的文件是否存在等等。有时客户端仅仅需要查看相应的头信息（Content-Type或者Content-Length）。在此类案例中客户端可以使用HEAD请求方法来检测头信息。HEAD方法与GET方法类似，但是HEAD方法不希望在响应信息中包含Message Body(实际页面)。

#### POST

Post方法一般用来访问动态资源，或者在向服务端发送大量的复杂信息的时候使用。Web服务器接收封装在Request中的实体，作为请求URI唯一标识的资源的附属。根据维基百科“提交数据被处理到唯一标识资源。数据被包含在请求的Body(Request Body)中。这可能会导致创建一个新的资源或者更新已有的资源或者两者兼之。”Get方法和Post方法的主要区别是：在Get方法请求中，请求参数是附加在请求URL最后来传输的，而在Post方法中，请求参数是被包含在请求体（Request Body）中传输的。

#### PUT

Put方法存储一个实体到指定的请求URI。该实体是Web服务端上指定请求URI下的资源。如果请求URI没有指向一个存在的资源，也能被发出请求的用户定义为一个新的资源，Web服务端将使用该URI创建资源。如果一个已经存在的资源被修改，200（OK）或者204（No Content）响应代码将被发送来表示成功修改资源。如果一个新的资源被创建，Web服务端必须向用户返回201(Created)相应代码。如果指定请求URI没有创建或者修改资源，将产生一个适当的错误响应，以反应问题的性质。

#### DELETE

Delete方法通过请求URI请求Web服务删除指定资源。该方法可能在Web服务端被人为的重写。如果响应信息中包含一个实体描述删除的状态，200（OK）相应代码指出资源已经被成功删除。如果响应代码是202（Accepted）,它指出资源还没有被删除。相似的，如果相应代码是204（No Content），它指出资源已经被删除但是响应代码不包含任何实体。

#### OPTIONS

根据维基百科“返回服务端针对指定的URL所支持的HTTP请求方法。用“*”代替资源名称，想Web服务器发送Options请求，可以测试服务器功能是否正常运作。"Options方法请求关于可请求URI所表示的请求/响应链上的用的通信选项的信息。该方法的响应信息不能被缓存。该方法允许客户端决定选项和/或要求与一种资源或者服务的功能相关联。如果Options方法包含一个实体，则media类型必须通过Content-Type字段来标明。

#### TRACE

根据维基百科“回显服务器收到的请求，这样客户端可以看到（如果有）哪一些改变或者添加已经被中间服务器实现。”Trace方法被用来调用与请求消息相关联的远程应用程序层。Trace请求必须包含一个实体。客户端使用Trace方法看到接收用户输入的请求链和诊断或检测信息的另一端。

#### CONNECT

HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。

### get比post更快的原因

**1** post请求包含更多的请求头

因为post需要在请求的body部分包含数据，所以会多了几个数据描述部分的首部字段（如content-type），这其实是微乎其微的

**2** post在真正接受数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据

post请求的过程：

1.浏览器请求tcp连接（第一次握手）

2.服务器答应进行tcp连接（第二次握手）

3.浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）

4.服务器返回100 continue响应

5.浏览器开始发送数据

6.服务器返回200 ok响应

get请求的过程：

1.浏览器请求tcp连接（第一次握手）

2.服务器答应进行tcp连接（第二次握手）

3.浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）

4.服务器返回200 ok响应

**3** get会将请求的静态数据缓存起来，而post不会

**4** post不能进行管道化传输

get 会造成服务器缓冲区溢出。

管道通信：

把需要发送到服务器上的所有请求放到输出队列中，在第一个请求发送出去后，不等到收到服务器的应答，第二个请求紧接着就发送出去，但是这样的方式有一个问题：不安全，如果一个管道中有10个连接，在发送出9个后，突然服务器告诉你，连接关闭了，此时客户端即使收到了前9个请求的答复，也会将这9个请求的内容清空，也就是说，白忙活了。此时，客户端的这9个请求需要重新发送。这对于幂等请求还好（比如get，多发送几次都没关系，每次都是相同的结果），如果是post这样的非幂等请求（比如支付的时候，多发送几次就惨了），肯定是行不通的。

Content-Type
-

- text/html ： HTML格式
- text/plain ：纯文本格式      
- text/xml ：  XML格式
- image/gif ：gif图片格式    
- image/jpeg ：jpg图片格式 
- image/png：png图片格式

- application/xhtml+xml ：XHTML格式
- application/xml     ： XML数据格式
- application/atom+xml  ：Atom XML聚合格式    
- application/json    ： JSON数据格式
- application/pdf       ：pdf格式  
- application/msword  ： Word文档格式
- application/octet-stream ： 二进制流数据（如常见的文件下载）
- application/x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

-  multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式




参考资料
-

<a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?fr=aladdin#3_2" target="_blank">HTTP状态码</a>

<a href="http://www.cnblogs.com/Herzog3/p/5881411.html" target="_blank">HTTP request</a>

<a href="http://www.cnblogs.com/strayling/p/3580048.html" target="_blank">为什么get比post更快</a>

<a href="http://blog.csdn.net/blueheart20/article/details/45174399" target="_blank">Http请求中Content-Type讲解以及在Spring MVC中的应用</a>

